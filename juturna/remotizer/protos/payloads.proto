syntax = "proto3";

package juturna.proto.payloads;

import "google/protobuf/any.proto";
import "google/protobuf/struct.proto";

// AudioPayloadProto represents audio data with metadata
// Uses raw bytes for maximum efficiency instead of repeated floats
message AudioPayloadProto {
  // Raw audio samples as bytes (use numpy.tobytes() for serialization)
  bytes audio_data = 1;
  
  // Data type of audio samples (e.g., "float32", "int16", "float64")
  string dtype = 2;
  
  // Shape of the audio array [samples, channels]
  // For mono: [samples], for stereo: [samples, 2]
  repeated int32 shape = 3;
  
  // Sampling rate in Hz (e.g., 44100, 48000)
  int32 sampling_rate = 4;
  
  // Number of audio channels (1 for mono, 2 for stereo, etc.)
  int32 channels = 5;
  
  // Start timestamp in seconds
  double start = 6;
  
  // End timestamp in seconds
  double end = 7;
}

// ImagePayloadProto represents a single frame/image
// Uses raw bytes for maximum compression efficiency
message ImagePayloadProto {
  // Raw pixel data as bytes (flattened array)
  // Reshape using: image_data.reshape(height, width, depth)
  bytes image_data = 1;
  
  // Data type of pixels (e.g., "uint8", "float32", "uint16")
  string dtype = 2;
  
  // Image width in pixels
  int32 width = 3;
  
  // Image height in pixels
  int32 height = 4;
  
  // Color depth (e.g., 1 for grayscale, 3 for RGB, 4 for RGBA)
  int32 depth = 5;
  
  // Pixel format (e.g., "RGB", "RGBA", "BGR", "GRAY", "HSV")
  string pixel_format = 6;
  
  // Frame timestamp in seconds
  double timestamp = 7;
}

// VideoPayloadProto represents a sequence of frames
message VideoPayloadProto {
  // Sequence of image frames
  repeated ImagePayloadProto frames = 1;
  
  // Frame rate in frames per second (fps)
  double frames_per_second = 2;
  
  // Video start timestamp in seconds
  double start = 3;
  
  // Video end timestamp in seconds
  double end = 4;
  
  // Optional: video codec information
  string codec = 5;
  
  // Optional: total duration in seconds (can be computed from start/end)
  double duration = 6;
}

// BytesPayloadProto for generic binary content
message BytesPayloadProto {
  // Raw binary content
  bytes content = 1;
  
  // Optional: MIME type or content type identifier
  string content_type = 2;
  
  // Optional: original filename if applicable
  string filename = 3;
  
  // Optional: size in bytes (can be computed from content.length)
  int64 size = 4;
}

// BatchProto represents a collection of messages
message BatchProto {
  // List of messages in the batch
  repeated MessageProto messages = 1;
  
  // Batch metadata as key-value pairs
  map<string, string> metadata = 2;
  
  // Batch creation timestamp
  double created_at = 3;
  
  // Unique batch identifier
  string batch_id = 4;
  
  // Optional: total size of batch in bytes
  int64 total_size = 5;
}

// ObjectPayloadProto for arbitrary key-value structures
// Equivalent to Python dict or JSON object
message ObjectPayloadProto {
  // Arbitrary structured data using protobuf Struct
  // Supports nested objects, arrays, strings, numbers, booleans, null
  google.protobuf.Struct data = 1;
  
  // Optional: schema version for the object structure
  string schema_version = 2;
}

// MessageProto represents a single message in the system
// This is the core message type that flows through nodes
message MessageProto {
  // MessageProto creation timestamp (Unix epoch in seconds)
  double created_at = 1;
  
  // Creator node name (identifies which node created this message)
  string creator = 2;
  
  // MessageProto version (indicates version of the data contained)
  int32 version = 3;
  
  // PayloadProto can be any of the payload types (AudioPayloadProto, ImagePayloadProto, etc.)
  google.protobuf.Any payload = 4;
  
  // Metadata as key-value pairs (flexible metadata storage)
  map<string, string> meta = 5;
  
  // Timers for performance tracking
  // Key: timer name, Value: elapsed time in seconds
  map<string, double> timers = 6;
}

// MessageProtoEnvelope is the top-level message sent over the wire
// It wraps a MessageProto and adds routing, correlation, and lifecycle information
message MessageProtoEnvelope {
  // Unique envelope identifier (UUID recommended)
  string id = 1;
  
  // The actual message being transported
  MessageProto message = 2;
  
  // Sender/source system identifier
  string sender = 3;
  
  // Intended receiver/target system identifier
  string receiver = 4;
  
  // Correlation ID for request/response coupling
  // Use the same correlation_id for related request/response pairs
  string correlation_id = 5;
  
  // Response-to field: ID of the envelope this is responding to
  // Enables explicit request/response tracking
  string response_to = 6;
  
  // Time-to-live in seconds
  // After this duration, the message may be considered stale/expired
  int64 ttl = 7;
  
  // Envelope creation timestamp (Unix epoch in seconds)
  double created_at = 8;
  
  // Configuration parameters as key-value pairs
  // Used for message-specific configuration or routing hints
  map<string, string> configuration = 9;
  
  // Envelope metadata as key-value pairs
  // Different from message.meta - this is envelope-level metadata
  map<string, string> metadata = 10;
  
  // message priority (0 = lowest, higher = more urgent)
  int32 priority = 11;
  
  // request type hint for faster routing/dispatching
  // e.g., "juturna.proto.payloads.AudioPayload"
  string request_type = 12;

  // response type hint for faster serialization
  // e.g., "juturna.proto.payloads.AudioPayload"
  string response_type = 13;

}

// Optional: Compressed payload wrapper for large data
message CompressedPayloadProto {
  // Compression algorithm used (e.g., "gzip", "zstd", "lz4")
  string compression = 1;
  
  // Compressed data
  bytes compressed_data = 2;
  
  // Original uncompressed size in bytes
  int64 original_size = 3;
  
  // Compressed size in bytes (can be computed from compressed_data.length)
  int64 compressed_size = 4;
  
  // Original payload type before compression
  string original_type = 5;
}